# TUGOL — Code RAG Full Snapshot (v1.0)

**Scope:**  
1) Code-Deep Snapshot  
2) DB-RAG (Schema & Queries)  
3) API-RAG (Current & Planned)  
4) Logic-RAG (Pricing / Panic / Time Slice)  
5) LLM-Collab Prompt Pack  

**Goal:**  
이 문서는 LLM이 TUGOL 코드를 기반으로:
- 분석 / 리팩토링 / 버그 수정
- 새로운 기능(기상, LBS, CRM 등) 추가
- DB/쿼리/트랜잭션 설계
- API 설계/확장
을 할 수 있게 돕는 **코드 중심 RAG 컨텍스트**다.

---

## 0. 전체 실행 플로우 (Runtime Overview)

```text
User → app/page.tsx (메인 예약 페이지)
     → DateSelector (14일 날짜 선택)
     → 3부제 필터 (05~10, 11~16, 17~)
     → Supabase: getTeeTimesByDate()
     → TeeTime 리스트 렌더링 (카드 UI)
     → BookingModal 열기
         → Toss Payment Widget 호출
         → 결제 성공 → /payment/success?params
         → 결제 실패 → /payment/fail?params
     → success 페이지에서 /api/payments/confirm 호출
         → Toss 서버 승인
         → Supabase: reservations INSERT
         → Supabase: tee_times.status = 'BOOKED'
```

---

# 1. Code-Deep Snapshot (High-Level 구조 + 의존성)

## 1.1 디렉토리 & 주요 파일

```text
app/
  page.tsx                      # 메인 예약 페이지
  layout.tsx                    # 공통 레이아웃
  api/payments/confirm/route.ts # 결제 승인 API
  payment/success/page.tsx      # 결제 성공 페이지
  payment/fail/page.tsx         # 결제 실패 페이지
  admin/page.tsx                # (조회 중심 Admin)

components/
  BookingModal.tsx              # 예약/결제 모달 (Toss Widget)
  DateSelector.tsx              # 날짜 선택(14일 칩 UI)

utils/supabase/
  queries.ts                    # tee_times 조회 함수

lib/
  supabase.ts                   # Supabase 클라이언트 생성

types/
  database.ts                   # Supabase 타입 정의
```

---

## 1.2 `app/page.tsx` (메인 예약 페이지)

역할:  
- 날짜 선택
- 3부제 필터
- 티타임 목록 렌더링
- BookingModal 호출
- (선택적으로) Panic 팝업

핵심 상태:

```ts
const [selectedDate, setSelectedDate] = useState<Date>(new Date());
const [selectedPart, setSelectedPart] = useState<'part1' | 'part2' | 'part3'>('part1');
const [teeTimes, setTeeTimes] = useState<TeeTimeWithPricing[]>([]);
const [selectedTeeTime, setSelectedTeeTime] = useState<TeeTimeWithPricing | null>(null);
const [isModalOpen, setIsModalOpen] = useState(false);
const [showPanic, setShowPanic] = useState(false);
```

티타임 로딩 (예시 구조):

```ts
useEffect(() => {
  (async () => {
    const data = await getTeeTimesByDate(selectedDate);
    setTeeTimes(data);
    if (data.length > 0 && Math.random() > 0.7) {
      setTimeout(() => setShowPanic(true), 2000);
    }
  })();
}, [selectedDate]);
```

3부제 필터:

```ts
const filteredTeeTimes = useMemo(() => {
  return teeTimes.filter((t) => {
    const hour = t.teeOffTime.getHours();
    if (selectedPart === 'part1') return hour >= 5 && hour < 11;
    if (selectedPart === 'part2') return hour >= 11 && hour < 17;
    return hour >= 17;
  });
}, [teeTimes, selectedPart]);
```

BookingModal 오픈:

```ts
const handleOpenModal = (teeTime: TeeTimeWithPricing) => {
  setSelectedTeeTime(teeTime);
  setIsModalOpen(true);
};
```

---

## 1.3 `components/DateSelector.tsx`

역할:
- 오늘 기준 14일 날짜 생성
- 칩 UI로 렌더링
- 선택된 날짜 강조 및 클릭 시 상위 컴포넌트에 전달

예시 구조:

```ts
interface DateSelectorProps {
  selectedDate: Date;
  onDateChange: (date: Date) => void;
}

const DateSelector: React.FC<DateSelectorProps> = ({ selectedDate, onDateChange }) => {
  const days = useMemo(() => {
    const base = new Date();
    return Array.from({ length: 14 }).map((_, i) => {
      const d = new Date(base);
      d.setDate(base.getDate() + i);
      return d;
    });
  }, []);

  const isSameDay = (d1: Date, d2: Date) =>
    d1.getFullYear() === d2.getFullYear() &&
    d1.getMonth() === d2.getMonth() &&
    d1.getDate() === d2.getDate();

  return (
    <div className="flex gap-2 overflow-x-auto">
      {days.map((d) => {
        const active = isSameDay(d, selectedDate);
        return (
          <button
            key={d.toISOString()}
            onClick={() => onDateChange(d)}
            className={`px-3 py-2 rounded-full text-sm whitespace-nowrap ${
              active ? 'bg-black text-white' : 'bg-gray-200 text-gray-700'
            }`}
          >
            {d.getMonth() + 1}/{d.getDate()}
          </button>
        );
      })}
    </div>
  );
};
```

---

## 1.4 `components/BookingModal.tsx`

역할:
- TeeTime 선택 후 결제 모달
- Toss Payment Widget 로딩 및 결제 요청

핵심 포인트:
- **Singleton 패턴**으로 위젯 1회만 초기화 (StrictMode 대응)
- `TeeTimeWithPricing` 타입을 page.tsx와 공유

예시 구조(단순화):

```ts
import { loadPaymentWidget, ANONYMOUS } from '@tosspayments/payment-widget-sdk';

interface BookingModalProps {
  isOpen: boolean;
  onClose: () => void;
  teeTime: TeeTimeWithPricing;
}

const BookingModal: React.FC<BookingModalProps> = ({ isOpen, onClose, teeTime }) => {
  const widgetRef = useRef<PaymentWidgetInstance | null>(null);
  const widgetElementRef = useRef<HTMLDivElement | null>(null);

  useEffect(() => {
    if (!isOpen) return;
    if (!widgetRef.current) {
      (async () => {
        const widget = await loadPaymentWidget('CLIENT_KEY', ANONYMOUS);
        widgetRef.current = widget;
        if (widgetElementRef.current) {
          widget.renderPaymentMethods(
            widgetElementRef.current,
            {
              amount: teeTime.finalPrice,
              orderId: String(teeTime.id),
              orderName: `TUGOL TeeTime ${teeTime.id}`,
            },
            { variantKey: 'DEFAULT' },
          );
        }
      })();
    }
  }, [isOpen, teeTime]);

  const handlePay = async () => {
    if (!widgetRef.current) return;
    await widgetRef.current.requestPayment({
      orderId: String(teeTime.id),
      orderName: `TUGOL TeeTime ${teeTime.id}`,
      successUrl: `${window.location.origin}/payment/success`,
      failUrl: `${window.location.origin}/payment/fail`,
    });
  };

  if (!isOpen || !teeTime) return null;

  return (
    <div className="modal">
      <div ref={widgetElementRef} />
      <button onClick={handlePay}>결제하기</button>
      <button onClick={onClose}>닫기</button>
    </div>
  );
};
```

---

## 1.5 `app/payment/success/page.tsx`

역할:
- Toss redirect 수신
- URL 파라미터 추출
- `/api/payments/confirm` 호출

Suspense 사용 (CSR 강제):

```ts
'use client';

import { Suspense } from 'react';
import { useSearchParams } from 'next/navigation';

const SuccessInner = () => {
  const params = useSearchParams();
  const paymentKey = params.get('paymentKey');
  const orderId = params.get('orderId');
  const amount = params.get('amount');

  useEffect(() => {
    if (!paymentKey || !orderId || !amount) return;
    (async () => {
      await fetch('/api/payments/confirm', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ paymentKey, orderId, amount: Number(amount) }),
      });
    })();
  }, [paymentKey, orderId, amount]);

  return <div>결제가 성공했습니다.</div>;
};

export default function Page() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <SuccessInner />
    </Suspense>
  );
}
```

---

## 1.6 `app/api/payments/confirm/route.ts`

역할:
- Toss 서버에 승인 요청
- 결제 금액/상태 검증
- DB에 reservation 기록 + tee_time status 업데이트

(구체 코드는 다를 수 있지만 구조 예시:)

```ts
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase';

export async function POST(req: NextRequest) {
  const { paymentKey, orderId, amount } = await req.json();
  try {
    // 1) Toss 서버 승인 요청
    const tossRes = await fetch('https://api.tosspayments.com/v1/payments/confirm', {
      method: 'POST',
      headers: {
        Authorization: `Basic ${Buffer.from('SECRET_KEY:').toString('base64')}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ paymentKey, orderId, amount }),
    });
    if (!tossRes.ok) {
      return NextResponse.json({ error: 'TOSS_CONFIRM_FAILED' }, { status: 400 });
    }
    const tossData = await tossRes.json();

    // 2) Supabase DB 업데이트
    const supabase = createClient();

    const { data: insertRes, error: insertErr } = await supabase
      .from('reservations')
      .insert({
        tee_time_id: Number(orderId),
        amount,
        payment_key: paymentKey,
        payment_status: 'PAID',
        status: 'CONFIRMED',
        receipt_url: tossData.receipt?.url ?? null,
      })
      .select()
      .single();

    if (insertErr) throw insertErr;

    const { error: updateErr } = await supabase
      .from('tee_times')
      .update({
        status: 'BOOKED',
        reserved_at: new Date().toISOString(),
      })
      .eq('id', Number(orderId));

    if (updateErr) throw updateErr;

    return NextResponse.json({ ok: true, reservation: insertRes });
  } catch (e) {
    return NextResponse.json({ error: 'CONFIRM_ERROR' }, { status: 500 });
  }
}
```

---

## 1.7 `lib/supabase.ts` (클라이언트)

```ts
import { createClient } from '@supabase/supabase-js';

export function createSupabaseServerClient() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!,
  );
}
```

(실제 구현은 다를 수 있으나 기본 구조는 위와 유사)

---

# 2. DB-RAG (Schema & Queries 중심)

## 2.1 테이블: `tee_times`

### 구조 요약

```sql
CREATE TABLE tee_times (
  id          BIGSERIAL PRIMARY KEY,
  tee_off     TIMESTAMPTZ NOT NULL,
  base_price  INTEGER NOT NULL,
  price       INTEGER NOT NULL,
  currency    TEXT DEFAULT 'KRW',
  status      TEXT NOT NULL CHECK (status IN ('OPEN','BOOKED','BLOCKED')),
  reserved_at TIMESTAMPTZ,
  reserved_by BIGINT
);
```

### 특징

- `tee_off`는 **UTC**로 저장, 프론트에서 KST로 변환
- `status`는 ENUM처럼 사용됨 (`OPEN`, `BOOKED`, `BLOCKED`)
- 예약 완료 시 `reserved_at`, `reserved_by` 채움

---

## 2.2 테이블: `reservations`

```sql
CREATE TABLE reservations (
  id             BIGSERIAL PRIMARY KEY,
  tee_time_id    BIGINT REFERENCES tee_times(id),
  user_id        BIGINT,
  status         TEXT NOT NULL, -- 'CONFIRMED' | 'CANCELLED' ...
  amount         INTEGER NOT NULL,
  payment_key    TEXT,
  payment_status TEXT, -- 'PAID' | 'FAILED'
  receipt_url    TEXT,
  created_at     TIMESTAMPTZ DEFAULT NOW()
);
```

---

## 2.3 주요 쿼리 예시

### 날짜별 티타임 조회

```sql
SELECT *
FROM tee_times
WHERE tee_off BETWEEN $1::timestamptz AND $2::timestamptz
ORDER BY tee_off ASC;
```

### 예약 생성 + 티타임 상태 변경 (개별)

```sql
INSERT INTO reservations (tee_time_id, user_id, status, amount, payment_key, payment_status, receipt_url)
VALUES ($1, $2, 'CONFIRMED', $3, $4, 'PAID', $5);

UPDATE tee_times
SET status = 'BOOKED',
    reserved_at = NOW(),
    reserved_by = $2
WHERE id = $1;
```

(추후엔 트랜잭션/Stored Procedure로 묶는 것을 추천)

---

## 2.4 DB 관련 TODO (LLM 작업 가능 포인트)

- [ ] Cancellation/Refund 로직에 맞는 `status` 전이 정의
- [ ] `user_segment`/CRM 필드 추가
- [ ] RLS 정책 설계 (예약 owner만 조회 등)
- [ ] Overbooking 방지용 transaction/lock 메커니즘
- [ ] TeeTime Generator (7분 간격 생성) Stored Procedure

---

# 3. API-RAG (현재/미래 API 설계용)

## 3.1 현재 구현된 API

### POST `/api/payments/confirm`

**Body:**

```json
{
  "paymentKey": "string",
  "orderId": "string | number",
  "amount": 120000
}
```

**Behavior (요약):**

1. Toss Payments `/payments/confirm` 호출
2. 승인/금액 검증
3. `reservations` INSERT
4. `tee_times.status = 'BOOKED'` 업데이트
5. JSON 응답 (`{ ok: true, reservation: ... }`)

에러 케이스:

- Toss 오류 → 4xx
- DB 오류 → 500 + `{ error: "CONFIRM_ERROR" }`

---

## 3.2 향후 설계 가능한 API (LLM 설계 대상)

아직 구현되지 않았지만 RAG에서 LLM이 설계/생성할 수 있는 API 후보들:

1. `GET /api/tee-times?date=YYYY-MM-DD&part=part1|2|3`
2. `POST /api/reservations/cancel`
3. `POST /api/admin/tee-times/block`
4. `POST /api/admin/tee-times/override-price`
5. `GET /api/pricing/simulate?date=...&weather=...`
6. `POST /api/webhook/toss` (Toss Webhook 처리용)

---

## 3.3 API 설계 시 고려사항

- Idempotency: `confirm` & `cancel`는 **중복 호출 방지** 필요
- Auth: Admin/일반 사용자 권한 구분 (Supabase Auth + RLS)
- Validation: `amount`, `currency`, `status` 필수 검증

---

# 4. Logic-RAG (Pricing / Panic / Time Slice 모델)

## 4.1 현재 구현된 로직들

### 날짜 선택 로직

- Today 기준 14일 생성 → UI 칩
- 선택 날짜 변경 시 `getTeeTimesByDate` 재호출

### Time Slice (3부제)

- Part 1: 05:00~10:59
- Part 2: 11:00~16:59
- Part 3: 17:00~ (Night)

### Dynamic Pricing UI

- DB `base_price` vs `price`를 UI에서 비교 노출
- **실제 알고리즘은 아직 단순** (할인/가중치는 미구현 혹은 Mock 수준)

---

## 4.2 기획 상 존재하는 Pricing 로직 (아직 코드 미반영)

(이 부분은 기존 기획서에서 온 내용이며, LLM이 구현 대상으로 삼을 수 있는 영역이다.)

- 기상 기반 할인:
  - `POP` (강수확률), `RN1` (강수량) → 할인율 산출
- LBS 기반 세그먼트:
  - 골프장 반경 5km/20km → Panic/Resident 할인
- 고객 세그먼트:
  - Future King, Prestige, Smart, Cherry Picker
  - 각 등급별 다른 할인 정책
- 임박 티 (Last minute):
  - 티오프 2시간 전부터 20분 간격 가격 인하
- Panic Mode:
  - 티오프 1시간 전, 거리 + 가용 시간 기준으로 특가 푸시

---

## 4.3 LLM이 구현/개선할 수 있는 로직 예시

- [ ] `getTeeTimesWithDynamicPrice(date, user, weather, location)` 함수 설계/구현
- [ ] 기상 API 응답 → 할인율 매핑 함수 (예: `calculateWeatherDiscount`)
- [ ] 고객 세그먼트 계산 함수 (`resolveUserSegment(userStats)`)
- [ ] 시간대/임박 할인 함수 (`calculateTimeDiscount(tee_off, now)`)
- [ ] 최종 가격 계산 파이프라인:
  ```ts
  finalPrice = basePrice
               * (1 - weatherDiscount)
               * (1 - timeDiscount)
               * (1 - segmentDiscount)
               - fixedCouponDiscount;
  ```

---

# 5. LLM-Collab Prompt Pack (협업용 프롬프트 세트)

아래 프롬프트들은 이 문서(`Code-RAG Full Snapshot`)를 붙여넣은 뒤 LLM에게 그대로 던지면 된다.  
필요시 변수(예: 함수명, 파일명)만 수정해서 사용.

---

## 5.1 Architect Prompt (아키텍트/설계용)

> **[SYSTEM]**  
> 너는 TUGOL(골프 다이내믹 프라이싱 예약 서비스)의 시니어 아키텍트이자 리드 엔지니어다.  
> 아래에 제공하는 `TUGOL — Code RAG Full Snapshot (v1.0)`을 기준으로만 판단하고,  
> 현재 구현된 코드와 DB 설계를 바탕으로, 신규 기능을 위해 **아키텍처/설계 레벨**에서 제안과 설계를 수행해라.  
> 
> **요청:**  
> - 기상청 POP/RN1 기반 다이내믹 프라이싱 로직을 추가하려고 한다.  
> - 어떤 모듈/파일에 어떤 함수를 추가하고, 어떤 데이터 구조를 바꾸면 좋은지,  
>   1) 설계 개요  
>   2) 변경 포인트 목록  
>   3) 타입/인터페이스 설계  
>   4) 단계별 구현 순서  
> 를 정리해줘.

---

## 5.2 Feature Dev Prompt (기능 개발용)

> **[DEVELOP]**  
> 아래 `Code RAG`를 기반으로,  
> `getTeeTimesByDate` 대신 `getTeeTimesWithPart(date, part)`를 사용하는 API를 추가하고 싶어.  
> 
> 요구사항:  
> 1. `part1 | part2 | part3`에 따라 SQL where 조건에서 시간대 필터링까지 처리  
> 2. 반환 타입은 기존 `TeeTimeWithPricing[]` 유지  
> 3. 프론트 `page.tsx`에서 3부제 필터가 서버 필터링을 사용하도록 수정  
> 
> - 수정해야 할 파일 목록  
> - 함수 시그니처  
> - 전체 코드 예시  
> 를 단계별로 제시해줘.  
> 기존 코드를 삭제하지 말고, 점진적으로 마이그레이션하는 전략으로 접근해줘.

---

## 5.3 Debug Prompt (디버깅용)

> **[DEBUG]**  
> TUGOL 프로젝트에서 아래와 같은 문제가 발생했다:  
> - 증상: 일부 사용자가 결제 성공 후에도 예약이 `BOOKED`로 바뀌지 않고 남아 있음.  
> - 환경: Production (Vercel), Supabase  
> - 관련 코드: `/payment/success/page.tsx`, `/api/payments/confirm/route.ts`, `tee_times`, `reservations`  
> 
> `Code RAG`에 있는 구조를 기준으로, 가능한 원인 후보를 5개 이상 나열하고,  
> 각 원인에 대해 **어떤 부분의 코드/DB를 점검해야 하는지**와  
> **어떻게 로깅/모니터링을 추가하면 재발 방지에 도움이 되는지** 구체적으로 설명해줘.

---

## 5.4 Refactor Prompt (리팩토링용)

> **[REFACTOR]**  
> 현재 `app/page.tsx`는:  
> - 티타임 로딩  
> - 날짜 선택  
> - 3부제 필터  
> - Panic 팝업 로직  
> - BookingModal 제어  
> 가 한 파일에 섞여 있어서 복잡도가 올라가고 있다.  
> 
> `Code RAG`의 구조를 바탕으로,  
> 1) 페이지를 `컨테이너/프레젠테이션` 패턴으로 분리하는 리팩토링 플랜과  
> 2) 필요한 새 컴포넌트/훅 목록 (`useTeeTimes`, `usePanicMode` 등)과  
> 3) 코드 예시 (부분이라도)  
> 를 제안해줘.  
> 
> 조건:  
> - 기능 동작은 유지  
> - 파일 수를 과하게 늘리지 말 것 (2~3개 정도로 분할)

---

## 5.5 DB/Query Prompt (DB 설계/확장용)

> **[DB DESIGN]**  
> 지금 TUGOL은 `tee_times`, `reservations` 테이블만 사용하고 있다.  
> 향후 CRM과 세그먼트(퓨처킹, 프레스티지, 체리피커)를 붙이기 위해,  
> `users`, `user_segments` 구조를 추가하려고 한다.  
> 
> `Code RAG`에 있는 현재 스키마를 고려하여,  
> 1) 추천 테이블 구조 (DDL 예시 포함)  
> 2) TUGOL의 예약/결제 흐름과 자연스럽게 연결되는 FK/인덱스 설계  
> 3) 차후 LBS/마케팅(푸시/알림)을 위한 필드를 어디에 저장할지  
> 를 제안해줘.  
> Supabase에서 RLS 정책을 나중에 적용할 수 있도록, 필드명/관계도도 같이 설명해줘.

---

## 5.6 Test Prompt (테스트/검증용)

> **[TEST]**  
> TUGOL MVP의 핵심 플로우는:  
> - 날짜 선택 → 티타임 조회 → 티타임 선택 → 결제 → `BOOKED` 상태 변경  
> 이다.  
> 
> 이 플로우에 대해,  
> 1) E2E 테스트 시나리오 (예: Playwright, Cypress 기반) 3개  
> 2) 단위 테스트 대상 함수 목록 (예: `getTeeTimesByDate`, `confirmPayment`)  
> 3) 각 테스트에서 반드시 검증해야 하는 Assertion 포인트  
> 를 설계해줘.

---

# END OF FILE (Code RAG Full v1.0)
